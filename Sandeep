Creating the Task Manager Using Java Spring Boot and Oracle Database
This implementation will include the full setup for a Spring Boot application with Oracle database integration, step-by-step instructions, and scripts for database setup.

Step 1: Set Up the Project
Use Spring Initializr

Go to Spring Initializr.
Select:
Project: Maven
Language: Java
Spring Boot Version: 3.x or higher
Add Dependencies:
Spring Web
Spring Data JPA
Spring Boot DevTools
Thymeleaf
Generate and download the project as a ZIP file. Extract it.
Add Oracle Database Driver Dependency Open the pom.xml file and add the Oracle database dependency:

xml
Copy code
<dependency>
    <groupId>com.oracle.database.jdbc</groupId>
    <artifactId>ojdbc8</artifactId>
    <version>19.19.0.0</version> <!-- Use the compatible version for your Oracle DB -->
</dependency>
Update Maven dependencies.

Step 2: Configure Oracle Database in Spring Boot
Create the Oracle Database

Connect to your Oracle database using a tool like SQL*Plus, Oracle SQL Developer, or any preferred client.
Run the following script to create the schema and table:
sql
Copy code
-- Create Schema
CREATE USER task_manager IDENTIFIED BY password;
GRANT CONNECT, RESOURCE TO task_manager;

-- Create Tasks Table
CREATE TABLE tasks (
    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    description VARCHAR2(255) NOT NULL,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    status VARCHAR2(50),
    reason_for_delay VARCHAR2(255)
);
Update application.properties File Configure Spring Boot to connect to the Oracle database:

properties
Copy code
spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
spring.datasource.username=task_manager
spring.datasource.password=password
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

spring.jpa.database-platform=org.hibernate.dialect.Oracle12cDialect
spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
Step 3: Create the Spring Boot Application
1. Entity Class
The Task entity represents the tasks table in the Oracle database.

java
Copy code
package com.taskmanager.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "tasks")
public class Task {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String description;

    private LocalDateTime startTime;
    private LocalDateTime endTime;

    private String status; // ONGOING, COMPLETED IN TIME, COMPLETED AFTER TIME, NOT COMPLETED, PENDING
    private String reasonForDelay;

    // Getters and Setters
}
2. Repository Interface
This interface provides CRUD operations for the Task entity.

java
Copy code
package com.taskmanager.repository;

import com.taskmanager.model.Task;
import org.springframework.data.jpa.repository.JpaRepository;

public interface TaskRepository extends JpaRepository<Task, Long> {
}
3. Service Class
The TaskService handles the business logic.

java
Copy code
package com.taskmanager.service;

import com.taskmanager.model.Task;
import com.taskmanager.repository.TaskRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class TaskService {
    private final TaskRepository taskRepository;

    public TaskService(TaskRepository taskRepository) {
        this.taskRepository = taskRepository;
    }

    public List<Task> getAllTasks() {
        return taskRepository.findAll();
    }

    public Task addTask(Task task) {
        task.setStatus("ONGOING");
        return taskRepository.save(task);
    }

    public Task updateTaskStatus(Long id, String status, String reason) {
        Task task = taskRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Task not found"));
        task.setStatus(status);
        if ("COMPLETED AFTER TIME".equals(status)) {
            task.setReasonForDelay(reason);
        }
        return taskRepository.save(task);
    }

    public void deleteTask(Long id) {
        taskRepository.deleteById(id);
    }
}
4. Controller Class
The TaskController handles HTTP requests.

java
Copy code
package com.taskmanager.controller;

import com.taskmanager.model.Task;
import com.taskmanager.service.TaskService;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;

@Controller
@RequestMapping("/tasks")
public class TaskController {
    private final TaskService taskService;

    public TaskController(TaskService taskService) {
        this.taskService = taskService;
    }

    @GetMapping
    public String viewTasks(Model model) {
        model.addAttribute("tasks", taskService.getAllTasks());
        return "task-list";
    }

    @GetMapping("/add")
    public String addTaskForm(Model model) {
        model.addAttribute("task", new Task());
        return "add-task";
    }

    @PostMapping("/add")
    public String addTask(@ModelAttribute Task task) {
        task.setStartTime(LocalDateTime.now());
        taskService.addTask(task);
        return "redirect:/tasks";
    }

    @PostMapping("/update/{id}")
    public String updateTask(@PathVariable Long id, @RequestParam String status, @RequestParam(required = false) String reason) {
        taskService.updateTaskStatus(id, status, reason);
        return "redirect:/tasks";
    }

    @PostMapping("/delete/{id}")
    public String deleteTask(@PathVariable Long id) {
        taskService.deleteTask(id);
        return "redirect:/tasks";
    }
}
Step 4: Frontend (Thymeleaf Templates)
1. Task List (task-list.html)
Displays all tasks.

html
Copy code
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Task Manager</title>
</head>
<body>
    <h1>Task Manager</h1>
    <a href="/tasks/add">Add Task</a>
    <table border="1">
        <tr>
            <th>ID</th>
            <th>Description</th>
            <th>Status</th>
            <th>Actions</th>
        </tr>
        <tr th:each="task : ${tasks}">
            <td th:text="${task.id}"></td>
            <td th:text="${task.description}"></td>
            <td th:text="${task.status}"></td>
            <td>
                <form th:action="@{/tasks/delete/{id}(id=${task.id})}" method="post">
                    <button type="submit">Delete</button>
                </form>
            </td>
        </tr>
    </table>
</body>
</html>
2. Add Task Form (add-task.html)
A form to add a new task.

html
Copy code
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Add Task</title>
</head>
<body>
    <h1>Add Task</h1>
    <form th:action="@{/tasks/add}" method="post">
        <label>Description: <input type="text" name="description" /></label>
        <label>End Time: <input type="datetime-local" name="endTime" /></label>
        <button type="submit">Add Task</button>
    </form>
</body>
</html>
Step 5: Run the Application
Start Oracle Database Ensure the Oracle database is running and accessible.

Run the Spring Boot Application Use the following command:

bash
Copy code
mvn spring-boot:run
Access the Application Open your browser and go to http://localhost:8080/tasks.

Step 6: Explain for Interview
Why Spring Boot with Oracle?

Spring Boot simplifies application setup with built-in tools.
Oracle Database is robust for enterprise-level applications.
How JPA Works?

JPA maps Java objects (entities) to database tables.
@Entity annotation indicates a persistent class.
Why Use Service Layer?

Separates business logic from controller logic.
Promotes code reuse and testability.
What Is Hibernate Dialect?

It tells Hibernate how to generate SQL queries for the target database (Oracle in this case).
What Is the Role of application.properties?

It configures the database connection and Hibernate behavior.
